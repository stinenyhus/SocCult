---
title: "Soc Kult exam"
author: "Marie"
date: "4/21/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load packages
```{r}
pacman::p_load(tidyverse,
               network,
               igraph,
               ggraph,
               tidygraph,
               intergraph,
               patchwork,
               statnet,
               magrittr,
               ggnetwork,
               EpiModel,
               #netdiffuseR
               )
```

Introducing status differences 
Status differences were created by assigning a few random nodes the ability to activate their neighbors without the need for social affirmation or reinforcement from additional sources. This enhanced influence might reflect higher social prestige, power, wealth, persuasiveness, etc. For convenience, we will refer to these as high-status nodes.

N/z of the nodes were randomly assigned to be high status (e.g., 5,000 high-status nodes in a population of 40,000) - (On average, this means that every neighborhood in the network can now be expected to have one high-status member). High-status nodes were given sufficient influence, t, to activate all of their neighbors (i.e., t ≥ a for τ = a/z) (t has to be bigger or equal to number of activativated nodes in the other (?) threshold with number of activated nodes out of number of neighbors

We need to make:
- high status nodes
- probabilistic threshold
- degree

Terminology in Centola and Macy:
- Threshold "t" as a fraction t = a/z, where "a" is the number of activated nodes and "z" is the number of neighbors. (In their example they say t = 6/48 and 1/8 and say that there is a difference in propagation when a = 1 and a > 1)
- High status nodes and influence: they were give sufficient influence i to activate all of their neighbors. i >= a for t = a/z.

Assumptions (p. 712):
- The network is "sparse" - most of the elements in the network are zero (at least in the beginnning)
- Thresholds are deterministic (probabbility of activation goes from 0-1 as threshold has been crossed)
- Every tie has equal influence 
- Every node has equal influence 
- Every node has identical threshold 
- Every node has about equal degree

Long ties on higher dimensional network - p.718:
- Used Moore neighborhood: includes nine nodes: on focal and its eight neighbors (four on the rows and columns and four on the diagonal). Z = 4r(r+1). Thus if radius is 1, degree (or neighborhood) will be 8. Maybe I don't get this.They get similar results when changing r.
- They used two values of degree: z = 8 and z = 48. Network density was held constant at 40,000 (when z = 8) and 240,000 (when z = 48).
- a (tresholds) varied from a = 1 to the critical upper limit (defined as a = 2*r^2 + 1). For z = 8, critical upper limit = 3 and for z = 48, critical upper limit = 19
- In each condition, the model was seeded with sufficient number of activated nodes to allow a contagion to spread on a lattice network. With complex contagion, a focal node was randomly selected and that node plus its neighbors was infected.

Small world window:
- at p = 10^-1 (0.1)

Links:
- https://dnac.ssri.duke.edu/r-labs/2017/04_diffusion_simulations.php
- https://kateto.net/netscix2016.html

# Setup
# 1. Construct a small world network
# 2. Choose one person at random, and set him/her and his/her neighbors as 
#    initial adopters
# 3. Infect all the people who have more than tau neighbors infected
# 4. Set the people who were infected at the previous round as "recovered"
# 5. Repeat steps


```{r}
### Set parameters in advance ###
tau <- 2/6 #they are working with fraction threshold 
max.time <- 50 
n <- 10000 
k <- 4
n_edges <- k*n/2

# high_node_tau <- 1/6

# Construct a small world network
set.seed(919)
sw.net <- igraph::watts.strogatz.game(1,n, 2, p = 0) %>%
  intergraph::asNetwork(.) 
plot(sw.net)

#Making Moore lattice without rewiring
moore <- make_lattice(c(sqrt(n),sqrt(n)), nei = 2) 
plot(moore, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = "Moore network")
moore <- moore %>% asNetwork(.) 
plot(moore)

#Making Moore lattice with rewiring
moore_re <- make_lattice(c(sqrt(n),sqrt(n)), nei =2) %>% rewire(each_edge(p = 10^-2)) %>% asNetwork(.)

plot(moore_re,
    #jitter = T,
    vertex.col = "Forestgreen",           # Node color
    vertex.border = "green",            # Node border color
    edge.col = "skyblue", 
    )

#scalefree
degs <- sample(1:150, n, replace=TRUE, prob=(1:150)^-2.3) #a vector of probability weights for obtaining the elements of the vector being sampled.
degs %>% 
  as.data.frame() %>% 
  filter(degs>100) %>% 
  count()

degs %>% 
  as.data.frame() %>% 
  filter(degs<10) %>% 
  count()

hist(degs)
if (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 } ### Note, that we correct the degree sequence if its sum is odd

scale_free <- sample_degseq(degs, method = "vl") 
scale_free <- scale_free %>% rewire(each_edge(p = 10^-3)) #centola-macy say that we should use this or lower rewiring prob 

all(igraph::degree(scale_free) == degs)
plot(scale_free, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5, xlab = "Scale-free network model")

scale_free <- scale_free %>% asNetwork(.)

#trying the sample_fitnss_pl
# scale_free_example <- sample_fitness_pl(10000, 30000, 2.2, 2.3)
# plot(scale_free_example, vertex.label= NA, edge.arrow.size=0.02, vertex.size = 0.5, xlab = "Scale-free network model")
# igraph::networkProperties(scale_free)
# 
# scale_free <- sample_fitness_pl(n, n_edges, 2.3)
# scale_free <- scale_free %>% rewire(each_edge(p = 10^-2))
# hist(igraph::degree(scale_free))
# 
# scale_free <- scale_free %>% intergraph::asNetwork()
# 
# plot(scale_free, vertex.label= NA, edge.arrow.size=0.02, vertex.size = 0.5, xlab = "Scale-free network model")
# hist(igraph::degree(scale_free))
# 
# plot(scale_free)
# plot(scale_free,
#     vertex.col = "Forestgreen",           # Node color
#     vertex.border = "green",            # Node border color
#     edge.col = "skyblue", 
#     )

```


```{r}
### Step 2: Choose a person & neighbors at random as an initial adopter ###
# Set up vector to indicate adoption
adopters <- rep(F, n) #repeat "FALSE" 50 times - initially none are infected
# Choose a person at random
initial.adopter <- base::sample(seq_len(n), size = 1) #takes one node from the sequence of nodes and classifies it as the inital adopter
#high.node <- base::sample(seq_len(n), size = 1)

# Get the list of people they're attached to
initial.neighbors <- get.neighborhood(sw.net, initial.adopter) #shows the 3 neighbors that the infected adopter has
initial.neighbors.moore <- get.neighborhood(moore_re, initial.adopter) #shows the 3 neighbors that the infected adopter has
initial.neighbors.scalefree <- get.neighborhood(asNetwork(g5), initial.adopter) #shows the 3 neighbors that the infected adopter has

#high node
# neighbors.highnode <- get.neighborhood(sw.net, high.node) #shows the 3 neighbors that the infected adopter has
# neighbors.highnode[1:2]

# Set them all as "adopters"
adopters[c(initial.adopter, initial.neighbors)] <- T #setting all neighbors to the initial infected node as infected
adopters[c(initial.adopter, initial.neighbors.moore)] <- T #setting all neighbors to the initial infected node as infected
adopters[c(initial.adopter, initial.neighbors.scalefree)] <- T #setting all neighbors to the initial infected node as infected

#high node
#adopters[c(high.node, neighbors.highnode)] <- T #setting all neighbors to the initial infected node as infected
```


```{r}
### Step 3: infect all people who have more than tau neighbors infected ###
## - and infect all people that have the highnode as their neighbor

# # Let's look at one person, person 20, to see how this works
# ego.extract(sw.net, ego = 20, neighborhood = "out") #ego.extract takes one or more input graphs (dat) and returns a list containing the egocentric networks centered on vertices named in ego, using adjacency rule neighborhood to define inclusion.
# ego.extract(moore, ego = 20, neighborhood = "out")
# ego.extract(g5, ego = 20, neighborhood = "out")
# 
# # Person 20
 adopters[20]
# 
# #Neighbors
 adopters[c(18, 19, 22, 21)]
# mean(adopters[c(18, 19, 22, 21)])
# 
# # To decide whether the person adopts, we test whether the fraction of
# # adopters is greater than tau
# mean(adopters[c(18, 19, 22, 21)]) >= tau  # adoption! - well non-adoption in this case

#nw adjancy
# We can update everyone simultaneously using matrix multiplication
 class(sw.net)
adj.mat.sw <- sw.net[, ] ## making our small world network an adjacency matrix
diag(adj.mat.sw) <- 0  # set the diagonal to 0, b/c people don't weight themselves

#make a tau matrix that has randomly sampled values from tau distribution
tau_norm_sw <- rnorm(nrow(adj.mat.sw), 0.33, .115)
tau_vec_sw <- as.vector(sample(tau_norm))

#making highnodes/influencers 
high_node_vec <- rep(F, 50)
influencer <- base::sample(seq_len(n), size = 1)
high_node_vec[c(influencer)] <- T
high_node_neighbors <- get.neighborhood(sw.net, influencer)
#high_node_vec[c(influencer, high_node_neighbors)] <- T

#gives the neighbors of the highnode
# adopters %*% high_node
high_node_vec[10] <- T
adopters & high_node_vec #highnode 10 is an adopter as well
active_high <- adopters & high_node_vec
ifelse(adopters, TRUE, ((adj.mat.sw %*% active_high) == 1))

# We could take the sum...
adj.mat.sw %*% adopters #%*% is matrix multiplication. For matrix multiplication, you need an m x n matrix times an n x p matrix.
#... or the percentage
(adj.mat.nw.rn <- adj.mat.sw / rowSums(adj.mat.sw))
# And then we calculate the people who are above our threshold
sw.ad <- adj.mat.nw.rn %*% adopters
(adj.mat.nw.rn %*% adopters) >= tau
(adj.mat.nw.rn %*% adopters) >= tau_vec

#moore adj
adj.mat.moore <- moore[, ]
diag(adj.mat.moore) <- 0 
# We could take the sum...
adj.mat.moore %*% adopters #%*% is matrix multiplication. For matrix multiplication, you need an m x n matrix times an n x p matrix.
#... or the percentage
(adj.mat.moore.rn <- adj.mat.moore / rowSums(adj.mat.moore))
# And then we calculate the people who are above our threshold
(adj.mat.moore.rn %*% adopters) >= tau

#scalefree
adj.mat.sf <- scale_free[, ]
adj.mat.sf
diag(adj.mat.sf) <- 0 
# We could take the sum...
adj.mat.sf %*% adopters
#... or the percentage
(adj.mat.sf.rn <- adj.mat.sf / rowSums(adj.mat.sf))
adj.mat.sf.rn %*% adopters
ifelse(adopters, TRUE, ((adj.mat.sf.rn %*% adopters) >= tau)) # i adopters hvis den er true (som den by default vil gemme) - ska den blive ved med at være true


# Note that this actually allows people to abandon the innovation if enough of
# of their neighbors are not adopters.  
#For now we don't want that to happen,so we'll only test people who are not yet adopters
ifelse(adopters, TRUE, ((adj.mat.rn %*% adopters) >= tau)) # i adopters hvis den er true (som den by default vil gemme) - ska den blive ved med at være true
```

```{r}
### Step 4: Repeat ###
# Again, we can take care of this by wrapping it in a loop
#
adopt <- vector(mode = "list", length = max.time) 

adopt[[1]] <- adopters

#sw net - basic
for (t in 2:max.time) {
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.nw.rn %*% adopt[[t - 1]]) >= tau)) #for the second element in the list "adopt" we test whether the fraction of adopters in the round before is greater than tau. we know that it will succeed the first round because we have determined the adopters to be infected. # we calculate the people who are above our threshold
  }

#sw net - med random tau!
for (t in 2:max.time) {
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.nw.rn %*% adopt[[t - 1]]) >= tau)) #for the second element in the list "adopt" we test whether the fraction of adopters in the round before is greater than tau. we know that it will succeed the first round because we have determined the adopters to be infected. # we calculate the people who are above our threshold
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.nw.rn %*% adopt[[t - 1]]) >= tau_vec)) 
}

#sw net - med high-node!
adopters[c(influencer)] <- T
adopt <- vector(mode = "list", length = max.time)
adopt[[1]] <- adopters

for (t in 2:max.time) {
  print(t)
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.nw.rn %*% adopt[[t - 1]]) >= tau)) #for the second element in the list "adopt" we test whether the fraction of adopters in the round before is greater than tau. we know that it will succeed the first round because we have determined the adopters to be infected. # we calculate the people who are above our threshold
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.sw %*% high_node_vec) == 1))
}

#moore
for (t in 2:max.time) {
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.moore.rn %*% adopt[[t - 1]]) >= tau)) #for the second element in the list "adopt" we test whether the fraction of adopters in the round before is greater than tau. we know that it will succeed the first round because we have determined the adopters to be infected. # we calculate the people who are above our threshold

    adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.moore.rn %*% adopt[[t - 1]]) >= tau)) 
}

#scalefree
for (t in 2:max.time) {
  adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.sf.rn %*% adopt[[t - 1]]) >= tau)) #for the second element in the list "adopt" we test whether the fraction of adopters in the round before is greater than tau. we know that it will succeed the first round because we have determined the adopters to be infected. # we calculate the people who are above our threshold

    adopt[[t]] <- ifelse(adopters, TRUE, ((adj.mat.sf.rn %*% adopt[[t - 1]]) >= tau)) 
}

# Note that again we get the characteristic S-shaped curve:
data.frame(
  t = 1:max.time,
  n.adopt = sapply(adopt, sum)
) %>%
  ggplot(aes(x = t, y = n.adopt)) + 
  geom_line()

# Let's plot a few frames
set.seed(330)
sw.net.layout <- ggnetwork(sw.net) %>% 
  rename(id = vertex.names)

sw.net.layout.by.time <- adopt %>%
  lapply(FUN = as.data.frame) %>% 
  lapply(FUN = set_names, value = "adopter") %>% 
  lapply(FUN = mutate, id = 1:n) %>%
  lapply(FUN = right_join, y = sw.net.layout, by = "id") %>% 
  bind_rows(.id = "t") %>% 
  mutate(t = as.integer(t))

sw.net.layout.by.time %>% 
 # filter(t < 10) %>% 
  ggplot(aes(xend = xend, yend = yend, x = x, y = y)) + 
  geom_edges(color = "lightgray") +
  geom_nodes(aes(color = adopter)) + 
  facet_wrap(~ t) + 
  theme_blank()

set.seed(330)
g5.net.layout <- ggnetwork(g5) %>% 
  rename(id = vertex.names)

g5.net.layout.by.time <- adopt %>%
  lapply(FUN = as.data.frame) %>% 
  lapply(FUN = set_names, value = "adopter") %>% 
  lapply(FUN = mutate, id = 1:50) %>%
  lapply(FUN = right_join, y = g5.net.layout, by = "id") %>% 
  bind_rows(.id = "t") %>% 
  mutate(t = as.integer(t))

g5.net.layout.by.time %>% 
  #filter(t > 30 & t < 40) %>% 
  ggplot(aes(xend = xend, yend = yend, x = x, y = y)) + 
  geom_edges(color = "lightgray") +
  geom_nodes(aes(color = adopter)) + 
  facet_wrap(~ t) + 
  theme_blank()
```

```{r}
g <- make_star(10)
plot(g)
E(g)
E(g)$weight <- seq(ecount(g))
strength(g)
strength(g, mode="out")
strength(g, mode="in")

```


